Both the org.hibernate.Session API and javax.persistence.EntityManager API represent a context for dealing with persistent data. 
This concept is called a persistence context.

Important terms
transient: the entity has just been instantiated and is not associated with a persistence context. It has no persistent representation in the database and typically no identifier value has been assigned (unless the assigned generator was used).
managed, or persistent: the entity has an associated identifier and is associated with a persistence context. 
detached: the entity has an associated identifier but is no longer associated with a persistence context (usually because the persistence context was closed or the instance was evicted from the context)
removed: the entity has an associated identifier and is associated with a persistence context, however, it is scheduled for removal from the database.

How to access Hibernate APIs from JPA?
Example shown below
Session session = entityManager.unwrap( Session.class );
SessionImplementor sessionImplementor = entityManager.unwrap( SessionImplementor.class );

SessionFactory sessionFactory = entityManager.getEntityManagerFactory().unwrap( SessionFactory.class );
---------------------------
Legacy Hibernate only supported proxy-based for lazy loading and always used diff-based dirty calculation. But now it does support Bytecode enhancement.
Hibernate supports the enhancement of an application Java domain model for the purpose of adding various persistence-related capabilities directly into the class.
- Lazy attribute loading
Think of this as partial loading support. Essentially, you can tell Hibernate that only part(s) of an entity should be loaded upon fetching from the database and when the other part(s) should be loaded as well. Note that this is very much different from the proxy-based idea of lazy loading which is entity-centric where the entityâ€™s state is loaded at once as needed. With bytecode enhancement, individual attributes or groups of attributes are loaded as needed.
You can specify lazy groups so they can be loaded independently of other groups
@Lob
@Basic( fetch = FetchType.LAZY )
@LazyGroup( "lobs" )
private Blob image;

In-line dirty tracking
Historically Hibernate only supported diff-based dirty calculations for determining which entities in a persistence context has changed. This essentially means that Hibernate would keep track of the last known state of an entity in regards to the database (typically the last read or write).
Then, as part of flushing the persistence context, Hibernate would walk every entity associated with the persistence context and check its current state against that "last known database state". 
This is by far the most thorough approach to dirty checking because it accounts for data-types that can change their internal state (java.util.Date is the prime example of this). However, in a persistence context with a large number of associated entities, it can also be a performance-inhibiting approach.
If your application does not need to care about "internal state changing data-type" use cases, bytecode-enhanced dirty tracking might be a worthwhile alternative to consider, especially in terms of performance.In this approach Hibernate will manipulate the bytecode of your classes to add "dirty tracking" directly to the entity, allowing the entity itself to keep track of which of its attributes have changed. During the flush time, Hibernate asks your entity what has changed rather than having to perform the state-diff calculations.
Interesting example given of how Hibernate used bytecode-enhanced bi-directional association.

Performing Enhancement:
- Runtime Enhancement
Some configuration properties have to be specified:
*hibernate.enhancer.enableDirtyTracking (default = false)
Enable dirty tracking feature in runtime bytecode enhancement.

*hibernate.enhancer.enableLazyInitialization (default = false)
Enable lazy loading feature in runtime bytecode enhancement. This way, even basic types (e.g. @Basic(fetch = FetchType.LAZY)) can be fetched lazily.

*hibernate.enhancer.enableAssociationManagement (default = false)
Enable association management feature in runtime bytecode enhancement which automatically synchronizes a bidirectional association when only one side is changed.

Hibernate provides Gradle and Maven plugins. 
For Maven
Hibernate provides a Maven plugin capable of providing build-time enhancement of the domain model as they are compiled as part of a Maven build.
The Maven plugin supports one additional configuration settings: failOnError, which controls what happens in case of error. The default behavior is to fail the build, but it can be set so that only a warning is issued.

How to make entities persistent?
Once you've created a new Java entity using `new` you can make it persistent by associating it to either Hibernate Session JPA EntityManager. 
entityManager.persist( person );

Obtain an entity reference without initializing its data
Sometimes referred to as lazy loading, the ability to obtain a reference to an entity without having to load its data is hugely important. The most common case being the need to create an association between an entity and another existing entity.
Book book = new Book();
book.setAuthor( entityManager.getReference( Person.class, personId ) );
The above works on the assumption that the entity is defined to allow lazy loading, generally through use of runtime proxies.

Entities in managed/persistent state may be manipulated by the application, and any changes will be automatically detected and persisted when the persistence context is flushed. There is no need to call a particular method to make your modifications persistent.
Person person = entityManager.find( Person.class, personId );
person.setName("John Doe");
entityManager.flush();
Person person = session.byId( Person.class ).load( personId );
person.setName("John Doe");
session.flush();

By default, when you modify an entity, all columns but the identifier are being set during update.
To fix this issue, you can use dynamic updates.
To enable dynamic updates, you need to annotate the entity with the @DynamicUpdate annotation:
@Entity(name = "Product")
@DynamicUpdate
public static class Product {

The dynamic update allows you to set just the columns that were modified in the associated entity.

refresh?

Working with detached data?
Detachment is possible in number of ways:
1) Once the persistence context is closed, all data that was associated with it becomes detached.
2) Clearing the persistence context
3) Evicting a particular entity from the persistence context makes it detached. 
4) And finally, serialization will make the deserialized form be detached (the original instance is still managed).
	
Detached data can still be manipulated, however, the persistence context will no longer automatically know about these modifications, and the application will need to intervene to make the changes persistent again.

Hibernate provides the option of reattaching. 
- Through lock
Person person = session.byId( Person.class ).load( personId );
//Clear the Session so the person entity becomes detached
session.clear();
person.setName( "Mr. John Doe" );

session.lock( person, LockMode.NONE ); 

- Through saveandupdate
Person person = session.byId( Person.class ).load( personId );
//Clear the Session so the person entity becomes detached
session.clear();
person.setName( "Mr. John Doe" );

session.saveOrUpdate( person );

Merging detached data
Merging is the process of taking an incoming entity instance that is in the detached state and copying its data over onto a new managed instance.

When the flush() method is called, the state of the entity is synchronized with the database.
f you do not want this synchronization to occur, or if you are processing a huge number of objects and need to manage memory efficiently, the evict() method can be used to remove the object and its collections from the first-level cache.
To detach all entities from the current persistence context, both the EntityManager and the Hibernate Session define a clear() method.

Cascading entity state transitions(Important)
JPA allows you to propagate the state transition from a parent entity to a child. For this purpose, the JPA javax.persistence.CascadeType defines various cascade types:
ALL
cascades all entity state transitions
PERSIST
cascades the entity persist operation.
MERGE
cascades the entity merge operation.
REMOVE
cascades the entity remove operation.
REFRESH
cascades the entity refresh operation.
DETACH
cascades the entity detach operation.
Additionally, the CascadeType.ALL will propagate any Hibernate-specific operation, which is defined by the org.hibernate.annotations.CascadeType enum:
SAVE_UPDATE
cascades the entity saveOrUpdate operation.
REPLICATE
cascades the entity replicate operation.
LOCK
cascades the entity lock operation.